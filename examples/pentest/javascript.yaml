# Playwright MCP Security Test Suite
# Tests for browser_run_code tool vulnerabilities
# All tests return structured JSON for programmatic analysis

metadata:
  version: "1.0"
  target: "Playwright MCP browser_run_code"
  author: "TraceForce SecureMCP"
  date: "2024"
  description: "Non-destructive security tests returning structured output"
  note: "All functions return JSON objects with consistent structure"

# Standard response structure:
# {
#   "test_id": "string",
#   "vulnerable": boolean,
#   "severity": "CRITICAL|HIGH|MEDIUM|LOW",
#   "details": object,
#   "error": string|null
# }

test_categories:
  - name: "Information Disclosure"
    severity: "HIGH"
    tests:
      - id: "INFO-001"
        name: "Local File Access via file:// Protocol"
        description: "Attempts to read local files using file:// protocol"
        code: |
          async () => {
            const testId = "INFO-001";
            try {
              const response = await fetch('file:///etc/passwd');
              const text = await response.text();
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  protocol_access: true,
                  status: response.status,
                  content_length: text.length,
                  content_preview: text.substring(0, 100)
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  protocol_access: false,
                  blocked: true,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"
        
      - id: "INFO-002"
        name: "Access Node.js process.env"
        description: "Attempts to access Node.js environment variables"
        code: |
          () => {
            const testId = "INFO-002";
            const hasProcess = typeof process !== 'undefined';
            
            if (hasProcess) {
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  process_accessible: true,
                  has_env: typeof process.env !== 'undefined',
                  env_keys: Object.keys(process.env || {}).length,
                  sample_keys: Object.keys(process.env || {}).slice(0, 5)
                },
                error: null
              };
            }
            
            return {
              test_id: testId,
              vulnerable: false,
              severity: "CRITICAL",
              details: {
                process_accessible: false,
                process_type: typeof process
              },
              error: null
            };
          }
        pass_condition: "vulnerable === false"

      - id: "INFO-003"
        name: "Access Node.js require() function"
        description: "Attempts to use Node.js require() to load modules"
        code: |
          () => {
            const testId = "INFO-003";
            const hasRequire = typeof require !== 'undefined';
            
            if (!hasRequire) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  require_accessible: false,
                  require_type: typeof require
                },
                error: null
              };
            }
            
            try {
              const fs = require('fs');
              const files = fs.readdirSync('/');
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  require_accessible: true,
                  fs_module_loaded: true,
                  files_read: files.length,
                  sample_files: files.slice(0, 5)
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: true,
                severity: "HIGH",
                details: {
                  require_accessible: true,
                  fs_module_loaded: false,
                  require_failed: true
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

      - id: "INFO-004"
        name: "Access process via multiple paths"
        description: "Tests all possible paths to process object"
        code: |
          () => {
            const testId = "INFO-004";
            const checks = {
              direct: typeof process !== 'undefined',
              window: typeof window.process !== 'undefined',
              globalThis: typeof globalThis.process !== 'undefined',
              global: typeof global !== 'undefined' && typeof global.process !== 'undefined'
            };
            
            const anyAccessible = Object.values(checks).some(v => v);
            
            return {
              test_id: testId,
              vulnerable: anyAccessible,
              severity: "CRITICAL",
              details: {
                access_paths: checks,
                any_path_accessible: anyAccessible
              },
              error: null
            };
          }
        pass_condition: "vulnerable === false"

  - name: "SSRF (Server-Side Request Forgery)"
    severity: "CRITICAL"
    tests:
      - id: "SSRF-001"
        name: "Localhost Access"
        description: "Attempts to access localhost services"
        code: |
          async () => {
            const testId = "SSRF-001";
            const targets = [
              'http://127.0.0.1:8080',
              'http://localhost:8080',
              'http://127.0.0.1:3000'
            ];
            
            const results = [];
            for (const url of targets) {
              try {
                const response = await fetch(url);
                results.push({
                  url,
                  accessible: true,
                  status: response.status,
                  status_text: response.statusText
                });
              } catch (error) {
                results.push({
                  url,
                  accessible: false,
                  error_type: error.name,
                  error_message: error.message
                });
              }
            }
            
            const anyAccessible = results.some(r => r.accessible);
            
            return {
              test_id: testId,
              vulnerable: anyAccessible,
              severity: "CRITICAL",
              details: {
                targets_tested: targets.length,
                accessible_count: results.filter(r => r.accessible).length,
                results
              },
              error: null
            };
          }
        pass_condition: "vulnerable === false"

      - id: "SSRF-002"
        name: "AWS Metadata Service Access"
        description: "Attempts to access AWS EC2 metadata endpoint"
        code: |
          async () => {
            const testId = "SSRF-002";
            const metadataUrl = 'http://169.254.169.254/latest/meta-data/';
            
            try {
              const response = await fetch(metadataUrl, { 
                method: 'GET',
                headers: { 'X-aws-ec2-metadata-token-ttl-seconds': '21600' }
              });
              const text = await response.text();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  metadata_accessible: true,
                  status: response.status,
                  content_length: text.length,
                  endpoints_preview: text.split('\n').slice(0, 10)
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  metadata_accessible: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

      - id: "SSRF-003"
        name: "Private IP Range Scan"
        description: "Attempts to access private network IPs"
        code: |
          async () => {
            const testId = "SSRF-003";
            const privateIPs = [
              '192.168.1.1',
              '192.168.0.1',
              '10.0.0.1',
              '172.16.0.1'
            ];
            
            const results = [];
            for (const ip of privateIPs) {
              try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 2000);
                
                const response = await fetch(`http://${ip}`, { 
                  signal: controller.signal 
                });
                clearTimeout(timeout);
                
                results.push({
                  ip,
                  accessible: true,
                  status: response.status
                });
              } catch (error) {
                results.push({
                  ip,
                  accessible: false,
                  error_type: error.name
                });
              }
            }
            
            const accessibleIPs = results.filter(r => r.accessible);
            
            return {
              test_id: testId,
              vulnerable: accessibleIPs.length > 0,
              severity: "CRITICAL",
              details: {
                total_tested: privateIPs.length,
                accessible_count: accessibleIPs.length,
                accessible_ips: accessibleIPs.map(r => r.ip),
                results
              },
              error: null
            };
          }
        pass_condition: "vulnerable === false"

      - id: "SSRF-004"
        name: "Cloud Metadata - GCP"
        description: "Attempts to access Google Cloud metadata"
        code: |
          async () => {
            const testId = "SSRF-004";
            const gcpUrl = 'http://metadata.google.internal/computeMetadata/v1/';
            
            try {
              const response = await fetch(gcpUrl, {
                headers: { 'Metadata-Flavor': 'Google' }
              });
              const text = await response.text();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  gcp_metadata_accessible: true,
                  status: response.status,
                  content_length: text.length
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  gcp_metadata_accessible: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

      - id: "SSRF-005"
        name: "Cloud Metadata - Azure"
        description: "Attempts to access Azure metadata"
        code: |
          async () => {
            const testId = "SSRF-005";
            const azureUrl = 'http://169.254.169.254/metadata/instance?api-version=2021-02-01';
            
            try {
              const response = await fetch(azureUrl, {
                headers: { 'Metadata': 'true' }
              });
              const text = await response.text();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  azure_metadata_accessible: true,
                  status: response.status,
                  content_length: text.length
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  azure_metadata_accessible: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

  - name: "Context Escape & Sandbox Bypass"
    severity: "CRITICAL"
    tests:
      - id: "ESCAPE-001"
        name: "Constructor Chain Escape"
        description: "Attempts to escape via constructor chain"
        code: |
          () => {
            const testId = "ESCAPE-001";
            
            try {
              const proc = this.constructor.constructor('return process')();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  escape_successful: true,
                  process_accessible: typeof proc !== 'undefined',
                  has_env: proc && typeof proc.env !== 'undefined',
                  process_keys: proc ? Object.keys(proc).slice(0, 10) : []
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  escape_successful: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

      - id: "ESCAPE-002"
        name: "Function Constructor Escape"
        description: "Attempts to access Node.js via Function constructor"
        code: |
          () => {
            const testId = "ESCAPE-002";
            
            try {
              const getProcess = new Function('return process');
              const proc = getProcess();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "CRITICAL",
                details: {
                  escape_successful: true,
                  process_accessible: typeof proc !== 'undefined',
                  has_env: proc && typeof proc.env !== 'undefined'
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "CRITICAL",
                details: {
                  escape_successful: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

      - id: "ESCAPE-003"
        name: "Prototype Pollution"
        description: "Tests if prototype pollution is isolated"
        code: |
          () => {
            const testId = "ESCAPE-003";
            
            // Pollute prototype
            Object.prototype.polluted = 'VULNERABLE';
            const test1 = {};
            const result1 = test1.polluted;
            
            // Create another object to test persistence
            const test2 = {};
            const result2 = test2.polluted;
            
            // Try to access from different context paths
            const windowTest = {}.polluted;
            const globalThisTest = {}.polluted;
            
            return {
              test_id: testId,
              vulnerable: result1 === 'VULNERABLE',
              severity: "MEDIUM",
              details: {
                pollution_works: result1 === 'VULNERABLE',
                persists_in_context: result2 === 'VULNERABLE',
                window_affected: windowTest === 'VULNERABLE',
                globalthis_affected: globalThisTest === 'VULNERABLE'
              },
              error: null,
              note: "Need to test across multiple evaluations to check full isolation"
            };
          }
        pass_condition: "Check manually: pollution should not persist across evaluations"

      - id: "ESCAPE-004"
        name: "window.open File Protocol"
        description: "Attempts to open local files"
        code: |
          () => {
            const testId = "ESCAPE-004";
            
            try {
              const w = window.open('file:///etc/passwd');
              const opened = w !== null;
              
              if (opened && w) {
                w.close();
              }
              
              return {
                test_id: testId,
                vulnerable: opened,
                severity: "HIGH",
                details: {
                  window_opened: opened,
                  window_type: typeof w,
                  file_protocol_allowed: opened
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "HIGH",
                details: {
                  window_opened: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

  - name: "Resource Exhaustion"
    severity: "MEDIUM"
    tests:
      - id: "RESOURCE-001"
        name: "Memory Exhaustion Test"
        description: "Attempts to consume excessive memory"
        code: |
          () => {
            const testId = "RESOURCE-001";
            const startTime = Date.now();
            
            try {
              const arr = [];
              for (let i = 0; i < 1000000; i++) {
                arr.push('x'.repeat(100));
              }
              const endTime = Date.now();
              const timeMs = endTime - startTime;
              
              return {
                test_id: testId,
                vulnerable: timeMs < 30000,
                severity: "MEDIUM",
                details: {
                  completed: true,
                  array_length: arr.length,
                  time_ms: timeMs,
                  memory_mb_estimate: (arr.length * 100) / (1024 * 1024),
                  has_timeout: false
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  completed: false,
                  has_limits: true,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false OR details.time_ms is reasonable"
        timeout: 15000

      - id: "RESOURCE-002"
        name: "Infinite Loop Protection"
        description: "Tests timeout on infinite loops"
        code: |
          () => {
            const testId = "RESOURCE-002";
            const start = Date.now();
            
            while(true) {
              // Emergency exit after 30 seconds
              if (Date.now() - start > 30000) {
                return {
                  test_id: testId,
                  vulnerable: true,
                  severity: "HIGH",
                  details: {
                    ran_for_ms: Date.now() - start,
                    timeout_protection: false,
                    infinite_loop_completed: true
                  },
                  error: null
                };
              }
            }
          }
        pass_condition: "Should timeout before completion"
        timeout: 5000

      - id: "RESOURCE-003"
        name: "Excessive DOM Manipulation"
        description: "Tests limits on DOM operations"
        code: |
          () => {
            const testId = "RESOURCE-003";
            const startTime = Date.now();
            
            try {
              for (let i = 0; i < 100000; i++) {
                document.body.appendChild(document.createElement('div'));
              }
              const endTime = Date.now();
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "MEDIUM",
                details: {
                  elements_created: document.body.children.length,
                  time_ms: endTime - startTime,
                  has_dom_limits: false
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  has_dom_limits: true,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "Should timeout or limit elements"
        timeout: 10000

  - name: "Code Injection"
    severity: "HIGH"
    tests:
      - id: "INJECT-001"
        name: "eval() Global Pollution"
        description: "Tests if eval affects global state"
        code: |
          () => {
            const testId = "INJECT-001";
            
            try {
              eval('globalThis.injected = "VULNERABLE"');
              const value = globalThis.injected;
              
              return {
                test_id: testId,
                vulnerable: value === "VULNERABLE",
                severity: "MEDIUM",
                details: {
                  eval_works: true,
                  global_polluted: value === "VULNERABLE",
                  injected_value: value
                },
                error: null,
                note: "Run twice to test if pollution persists across evaluations"
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  eval_works: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "Check persistence across multiple runs"

      - id: "INJECT-002"
        name: "setTimeout String Code"
        description: "Tests setTimeout with string code"
        code: |
          async () => {
            const testId = "INJECT-002";
            
            return new Promise((resolve) => {
              try {
                setTimeout('globalThis.timeoutInjected = "VULNERABLE"', 10);
                setTimeout(() => {
                  const value = globalThis.timeoutInjected;
                  resolve({
                    test_id: testId,
                    vulnerable: typeof value !== 'undefined',
                    severity: "MEDIUM",
                    details: {
                      setTimeout_string_works: typeof value !== 'undefined',
                      injected_value: value,
                      value_type: typeof value
                    },
                    error: null
                  });
                }, 100);
              } catch (error) {
                resolve({
                  test_id: testId,
                  vulnerable: false,
                  severity: "MEDIUM",
                  details: {
                    setTimeout_string_works: false,
                    error_type: error.name
                  },
                  error: error.message
                });
              }
            });
          }
        pass_condition: "vulnerable === false"

  - name: "Data Exfiltration"
    severity: "HIGH"
    tests:
      - id: "EXFIL-001"
        name: "External Beacon"
        description: "Tests sendBeacon to external server"
        code: |
          () => {
            const testId = "EXFIL-001";
            
            try {
              const result = navigator.sendBeacon('https://httpbin.org/post', 'test_data');
              
              return {
                test_id: testId,
                vulnerable: result,
                severity: "MEDIUM",
                details: {
                  beacon_sent: result,
                  can_exfiltrate: result,
                  method: 'sendBeacon'
                },
                error: null,
                note: "Browser may legitimately allow external requests"
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  beacon_sent: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "Depends on security policy"

      - id: "EXFIL-002"
        name: "WebSocket Connection"
        description: "Tests WebSocket to external server"
        code: |
          () => {
            const testId = "EXFIL-002";
            
            try {
              const ws = new WebSocket('wss://echo.websocket.org');
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "MEDIUM",
                details: {
                  websocket_created: true,
                  ready_state: ws.readyState,
                  can_establish_ws: true
                },
                error: null,
                note: "WebSocket connections may be legitimately allowed"
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  websocket_created: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "Depends on security policy"

      - id: "EXFIL-003"
        name: "Fetch POST to External API"
        description: "Tests POST request to external API"
        code: |
          async () => {
            const testId = "EXFIL-003";
            
            try {
              const response = await fetch('https://httpbin.org/post', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({test: 'data', timestamp: Date.now()})
              });
              
              return {
                test_id: testId,
                vulnerable: response.ok,
                severity: "MEDIUM",
                details: {
                  request_sent: true,
                  status: response.status,
                  can_post_external: response.ok
                },
                error: null,
                note: "External requests are normal browser behavior"
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "MEDIUM",
                details: {
                  request_sent: false,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "Depends on CORS/CSP policy"

  - name: "Cross-Origin Access"
    severity: "MEDIUM"
    tests:
      - id: "CORS-001"
        name: "Cross-Origin Fetch"
        description: "Tests CORS policy enforcement"
        code: |
          async () => {
            const testId = "CORS-001";
            
            try {
              const response = await fetch('https://example.com/');
              const text = await response.text();
              
              return {
                test_id: testId,
                vulnerable: false,
                severity: "LOW",
                details: {
                  fetch_succeeded: true,
                  status: response.status,
                  content_length: text.length,
                  cors_headers_present: response.headers.has('access-control-allow-origin')
                },
                error: null,
                note: "Success depends on target's CORS headers (expected behavior)"
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "LOW",
                details: {
                  fetch_succeeded: false,
                  cors_blocked: error.message.includes('CORS'),
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "CORS properly enforced"

      - id: "CORS-002"
        name: "Parent Frame Access"
        description: "Tests cross-origin frame access"
        code: |
          () => {
            const testId = "CORS-002";
            
            try {
              const href = parent.location.href;
              
              return {
                test_id: testId,
                vulnerable: true,
                severity: "HIGH",
                details: {
                  parent_accessible: true,
                  parent_href: href,
                  cross_origin_access: true
                },
                error: null
              };
            } catch (error) {
              return {
                test_id: testId,
                vulnerable: false,
                severity: "HIGH",
                details: {
                  parent_accessible: false,
                  cross_origin_blocked: true,
                  error_type: error.name
                },
                error: error.message
              };
            }
          }
        pass_condition: "vulnerable === false"

# Test execution configuration
execution_config:
  default_timeout: 10000
  timeouts:
    RESOURCE-001: 15000
    RESOURCE-002: 5000
    RESOURCE-003: 10000

# Severity scoring
severity_levels:
  CRITICAL:
    score: 10
    auto_fail: true
  HIGH:
    score: 7
    max_failures: 2
  MEDIUM:
    score: 4
    max_failures: 5
  LOW:
    score: 1
    max_failures: 10

# Go struct for parsing results
go_structures:
  test_result: |
    type TestResult struct {
        TestID      string                 `json:"test_id"`
        Vulnerable  bool                   `json:"vulnerable"`
        Severity    string                 `json:"severity"`
        Details     map[string]interface{} `json:"details"`
        Error       *string                `json:"error"`
        Note        string                 `json:"note,omitempty"`
    }
  
  summary: |
    type TestSummary struct {
        TotalTests      int            `json:"total_tests"`
        Passed          int            `json:"passed"`
        Failed          int            `json:"failed"`
        Critical        int            `json:"critical_failures"`
        High            int            `json:"high_failures"`
        Medium          int            `json:"medium_failures"`
        Low             int            `json:"low_failures"`
        OverallSafe     bool           `json:"overall_safe"`
        FailedTests     []string       `json:"failed_tests"`
    }