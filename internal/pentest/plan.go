package pentest

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"gopkg.in/yaml.v3"
)

func (t *PentestTool) GeneratePentestPlan(ctx context.Context, tools []mcp.Tool, mcpServerName string) (string, error) {
	riskyTools, err := t.IdentifyRiskyTools(ctx, tools)
	if err != nil {
		return "", err
	}

	var responses []string
	for _, tool := range riskyTools {
		prompt := t.GenerateSecurityTestPrompt(tool, mcpServerName)
		fmt.Printf("Pentest plan prompt generated with length %v\n", len(prompt))
		response, err := t.llmClient.CallLLM(ctx, prompt)
		if err != nil {
			return "", err
		}
		responses = append(responses, response)
	}

	mergedYAML, err := mergeYAMLResponses(responses, mcpServerName)
	return mergedYAML, nil
}

func (t *PentestTool) IdentifyRiskyTools(ctx context.Context, tools []mcp.Tool) ([]mcp.Tool, error) {
	prompt := t.GenerateRiskyToolsPrompt(tools)
	fmt.Printf("Risky tools prompt generated with length %v\n", len(prompt))
	response, err := t.llmClient.CallLLM(ctx, prompt)
	if err != nil {
		return nil, err
	}
	var riskyToolNames []string
	if err := json.Unmarshal([]byte(response), &riskyToolNames); err != nil {
		return nil, err
	}
	var riskyTools []mcp.Tool
	for _, toolName := range riskyToolNames {
		fmt.Printf("Adding risky tool: %s\n", toolName)
		for _, tool := range tools {
			if tool.Name == toolName {
				riskyTools = append(riskyTools, tool)
				break
			}
		}
	}
	return riskyTools, nil
}

func (t *PentestTool) GenerateRiskyToolsPrompt(tools []mcp.Tool) string {
	var sb strings.Builder

	sb.WriteString("You are a security expert specializing in identifying high-risk tools and APIs.\n\n")
	sb.WriteString("# Your Task\n")
	sb.WriteString("Analyze the provided MCP tools and identify ONLY the high-risk ones based on their names and descriptions.\n\n")
	sb.WriteString("A tool is considered HIGH RISK if it has one or more of these characteristics:\n\n")
	sb.WriteString("## High-Risk Indicators\n\n")
	sb.WriteString("1. **System/File Operations**: Tools that can read, write, delete, or execute files or system commands\n")
	sb.WriteString("   - Examples: file operations, shell execution, command execution, process management\n\n")
	sb.WriteString("2. **Network Operations**: Tools that can make arbitrary network requests or access internal resources\n")
	sb.WriteString("   - Examples: HTTP requests, SSRF capabilities, network scanning, internal service access\n\n")
	sb.WriteString("3. **Data Access**: Tools that can access sensitive data, databases, or credentials\n")
	sb.WriteString("   - Examples: database queries, credential access, secret management, user data access\n\n")
	sb.WriteString("4. **Authentication/Authorization**: Tools that can modify authentication or authorization settings\n")
	sb.WriteString("   - Examples: user creation, permission changes, token generation, role management\n\n")
	sb.WriteString("5. **Code Execution**: Tools that can execute code, scripts, or arbitrary commands\n")
	sb.WriteString("   - Examples: code execution, script running, command injection vectors\n\n")
	sb.WriteString("6. **Resource Manipulation**: Tools that can modify system resources, configurations, or infrastructure\n")
	sb.WriteString("   - Examples: cloud resource management, infrastructure changes, configuration modifications\n\n")
	sb.WriteString("7. **Bypass/Security Controls**: Tools that can bypass security controls or access restricted areas\n")
	sb.WriteString("   - Examples: privilege escalation, security bypass, restricted access\n\n")

	sb.WriteString("# Output Format\n\n")
	sb.WriteString("Return a JSON array containing ONLY the names of the high-risk tools. Format:\n\n")
	sb.WriteString("```json\n")
	sb.WriteString("[\"tool_name_1\", \"tool_name_2\", \"tool_name_3\"]\n")
	sb.WriteString("```\n\n")
	sb.WriteString("**Important:**\n")
	sb.WriteString("- Return ONLY the tool names, not descriptions or other information\n")
	sb.WriteString("- Return ONLY high-risk tools - be conservative and only include tools that clearly match the high-risk indicators\n")
	sb.WriteString("- If no tools are high-risk, return an empty array: []\n")
	sb.WriteString("- Return valid JSON only, no additional text or explanations\n\n")

	sb.WriteString("# Tools to Analyze\n\n")

	// Add each tool with name and first 1000 bytes of description
	for i, tool := range tools {
		sb.WriteString(fmt.Sprintf("## Tool %d: %s\n\n", i+1, tool.Name))
		desc := tool.Description
		if len(desc) > 1000 {
			desc = desc[:1000]
		}
		sb.WriteString(fmt.Sprintf("**Description:** %s\n\n", desc))
	}

	sb.WriteString("# Instructions\n\n")
	sb.WriteString("1. **Analyze each tool** based on its name and description (first 1000 bytes)\n")
	sb.WriteString("2. **Identify high-risk tools** that match one or more of the high-risk indicators\n")
	sb.WriteString("3. **Be conservative** - only include tools that are clearly high-risk\n")
	sb.WriteString("4. **Return only the tool names** in a JSON array format\n")
	sb.WriteString("5. **Return valid JSON only** - no markdown, no explanations, just the JSON array\n\n")

	sb.WriteString("BEGIN JSON OUTPUT:\n")

	return sb.String()
}

// GenerateSecurityTestPrompt creates a general prompt for an LLM to generate security tests for any MCP
func (t *PentestTool) GenerateSecurityTestPrompt(tool mcp.Tool, serverName string) string {
	var sb strings.Builder

	sb.WriteString("You are a security testing expert specializing in API and MCP (Model Context Protocol) security.\n\n")
	sb.WriteString("# Your Task\n")
	sb.WriteString("Analyze the provided MCP tool descriptions and input schemas, then generate a security test plan in YAML format.\n\n")
	sb.WriteString("Focus on the top 3-5 most critical security vulnerabilities that apply to these specific tools.\n\n")

	sb.WriteString("# Security Test Categories to Consider\n\n")
	sb.WriteString("Evaluate each tool and determine which of these vulnerabilities apply:\n\n")

	sb.WriteString("## 1. Injection Attacks\n")
	sb.WriteString("- SQL/NoSQL injection in query parameters\n")
	sb.WriteString("- Command injection in system parameters\n")
	sb.WriteString("- Code injection in executable parameters\n")
	sb.WriteString("- Path traversal in file/directory parameters\n")
	sb.WriteString("- LDAP/XML/template injection where applicable\n\n")

	sb.WriteString("## 2. Authentication & Authorization\n")
	sb.WriteString("- Missing authentication checks\n")
	sb.WriteString("- Privilege escalation attempts\n")
	sb.WriteString("- Cross-tenant/cross-user data access\n")
	sb.WriteString("- Token/credential leakage in responses\n")
	sb.WriteString("- Session/token manipulation\n\n")

	sb.WriteString("## 3. Server-Side Request Forgery (SSRF)\n")
	sb.WriteString("- Internal network access via URL parameters\n")
	sb.WriteString("- Cloud metadata service access (AWS, GCP, Azure)\n")
	sb.WriteString("- Localhost/127.0.0.1 access\n")
	sb.WriteString("- Private IP range access (10.x, 172.16.x, 192.168.x)\n")
	sb.WriteString("- Protocol smuggling (file://, gopher://, etc.)\n\n")

	sb.WriteString("## 4. Input Validation\n")
	sb.WriteString("- Oversized inputs causing DoS (use bounded sizes: 1MB, 5MB, up to 10MB - NOT infinite)\n")
	sb.WriteString("- Special characters breaking parsing\n")
	sb.WriteString("- Unicode/encoding issues\n")
	sb.WriteString("- Null byte injection\n")
	sb.WriteString("- Format string vulnerabilities\n")
	sb.WriteString("- **DO NOT create infinite loop tests** - use bounded iterations up to 100000 iterations if testing timeout controls\n")
	sb.WriteString("- **DO NOT create unbounded memory allocation tests** - use explicit size limits up to 10MB\n\n")

	sb.WriteString("## 5. Information Disclosure\n")
	sb.WriteString("- Sensitive data in error messages (tokens, passwords, keys)\n")
	sb.WriteString("- Stack traces revealing internal paths\n")
	sb.WriteString("- Debug information in responses\n")
	sb.WriteString("- Internal IP addresses or hostnames\n")
	sb.WriteString("- Database query details\n")
	sb.WriteString("- System/version information\n\n")

	sb.WriteString("# Output Format\n\n")
	sb.WriteString("Generate YAML following this structure:\n\n")
	sb.WriteString("```yaml\n")
	sb.WriteString("metadata:\n")
	sb.WriteString("  version: \"1.0\"\n")
	sb.WriteString(fmt.Sprintf("  target: \"%s\"\n", serverName))
	sb.WriteString("  focus: \"Critical security vulnerabilities\"\n\n")
	sb.WriteString("tests:\n")
	sb.WriteString("  - test_id: \"SEC-001\"\n")
	sb.WriteString("    name: \"[Descriptive vulnerability name]\"\n")
	sb.WriteString("    purpose: |\n")
	sb.WriteString("      Explain what vulnerability this tests and why it's critical.\n")
	sb.WriteString("      Include potential impact if exploited.\n")
	sb.WriteString("    severity: \"CRITICAL\"  # CRITICAL, HIGH, MEDIUM, or LOW\n")
	sb.WriteString("    \n")
	sb.WriteString("    prerequisites:  # Optional - only if test needs setup\n")
	sb.WriteString("      - description: \"How to obtain this value\"\n")
	sb.WriteString("        variable: \"VARIABLE_NAME\"\n")
	sb.WriteString("    \n")
	sb.WriteString("    test_cases:\n")
	sb.WriteString("      - case_id: \"SEC-001-A\"\n")
	sb.WriteString("        description: \"Specific attack vector being tested\"\n")
	sb.WriteString("        input:\n")
	sb.WriteString("          tool: \"toolName\"\n")
	sb.WriteString("          arguments:\n")
	sb.WriteString("            param1: \"attack_payload\"\n")
	sb.WriteString("            param2: \"value\"\n")
	sb.WriteString("        expected_output:\n")
	sb.WriteString("          error_present: true\n")
	sb.WriteString("          error_code_one_of: [400, 403, 404, -32602]\n")
	sb.WriteString("          result: null\n")
	sb.WriteString("```\n\n")

	sb.WriteString("# Expected Output Field Descriptions\n\n")
	sb.WriteString("**REQUIRED FIELDS (must be present in every test case):**\n")
	sb.WriteString("- error_present: REQUIRED - true (should return error), false (should not return any error)\n\n")
	sb.WriteString("**Optional Fields:**\n")
	sb.WriteString("- error_code_one_of: List of acceptable error codes\n")
	sb.WriteString("- result: Expected result value, null if should not return data\n")
	sb.WriteString("- error_response_must_not_match_regex: Full response must NOT match these regex patterns\n")
	sb.WriteString("**CRITICAL: Every test case MUST include the 'error_present' field in expected_output.**\n\n")
	sb.WriteString("## When to Use error_present: true vs false\n\n")
	sb.WriteString("**For ATTACK SCENARIOS (credential exfiltration, SSRF, code injection, path traversal, etc.):**\n")
	sb.WriteString("- Use `error_present: true` - A properly secured system should BLOCK these attacks\n")
	sb.WriteString("- Include `error_code_one_of` with appropriate error codes (400, 403, 404, -32602, etc.)\n")
	sb.WriteString("- Use `error_response_must_not_match_regex` to ensure error messages don't leak sensitive data\n")
	sb.WriteString("- Example: Attempting to read /etc/passwd should return an error, not the file contents\n\n")
	sb.WriteString("- If a specific string is used in the attack (e.g., \"/etc/passwd\"), the error message may naturally include this string - this is expected behavior, not information leakage. DO NOT use a regex pattern to match the attack payload itself in error messages.\n")
	sb.WriteString("**For INFORMATION DISCLOSURE CHECKS on legitimate operations:**\n")
	sb.WriteString("- Use `error_present: false` - The operation should succeed\n")
	sb.WriteString("- Use `error_response_must_not_match_regex` to ensure successful responses don't leak sensitive data\n")
	sb.WriteString("- Example: A valid API call should work but shouldn't expose tokens in the response\n\n")
	sb.WriteString("**For INFORMATION DISCLOSURE CHECKS on any operations that are expected to fail:**\n")
	sb.WriteString("- Use `error_present: true` - The operation should fail (as expected for the attack)\n")
	sb.WriteString("- Use `error_response_must_not_match_regex` to ensure error messages don't leak sensitive data\n")
	sb.WriteString("- If a specific string is used in the operation (e.g., \"auth.users\"), the error message may naturally include this string - this is expected behavior, not information leakage. DO NOT use a regex pattern to match the attack payload itself in error messages.\n")
	sb.WriteString("- Example: An invalid file path should return an error, but the error shouldn't expose internal paths\n\n")

	sb.WriteString("# Test Generation Guidelines\n\n")
	sb.WriteString("## Safety Requirements\n")
	sb.WriteString("**CRITICAL: Follow these safety rules to prevent system hangs or resource exhaustion:**\n\n")
	sb.WriteString("1. **NEVER create tests with infinite loops** (e.g., `while(true)`, recursive calls without bounds)\n")
	sb.WriteString("2. **NEVER create tests that allocate memory indefinitely** (e.g., growing arrays without bounds)\n")
	sb.WriteString("3. **All DoS tests must use bounded inputs**:\n")
	sb.WriteString("   - Use large but finite strings (e.g., up to 10MB, not infinite)\n")
	sb.WriteString("   - Use bounded loops with explicit limits, up to 100000 iterations\n")
	sb.WriteString("   - Use timeouts or iteration limits in any code execution tests\n")
	sb.WriteString("4. **When writing tests with await operations**: ALWAYS include a timeout of 20000 milliseconds (20 seconds) on all await operations. Example: `await page.goto(url, { timeout: 20000 })` instead of `await page.goto(url)`\n\n")

	sb.WriteString("## Prioritization\n")
	sb.WriteString("1. Rank tests by severity: CRITICAL > HIGH > MEDIUM > LOW\n")
	sb.WriteString("2. Focus on vulnerabilities that could lead to:\n")
	sb.WriteString("   - Data breaches or unauthorized access\n")
	sb.WriteString("   - System compromise or code execution\n")
	sb.WriteString("   - Privilege escalation\n")
	sb.WriteString("3. Limit to 3 most important tests per tool, with 2 test cases each\n\n")

	sb.WriteString("## Attack Payloads by Parameter Type\n\n")
	sb.WriteString("### URL/URI Parameters\n")
	sb.WriteString("Test with:\n")
	sb.WriteString("- http://169.254.169.254/latest/meta-data/ (AWS metadata)\n")
	sb.WriteString("- http://127.0.0.1:PORT\n")
	sb.WriteString("- http://localhost:PORT\n")
	sb.WriteString("- http://10.0.0.1 (private IP)\n")
	sb.WriteString("- file:///etc/passwd (local files)\n\n")

	sb.WriteString("### ID/Key Parameters\n")
	sb.WriteString("Test with:\n")
	sb.WriteString("- ../../../etc/passwd (path traversal)\n")
	sb.WriteString("- 00000000-0000-0000-0000-000000000000 (invalid UUID)\n")
	sb.WriteString("- 999999999 (non-existent ID)\n")
	sb.WriteString("- <script>alert('xss')</script> (injection)\n")
	sb.WriteString("- '; DROP TABLE x; -- (SQL injection)\n\n")

	sb.WriteString("### Query/Search Parameters\n")
	sb.WriteString("Test with:\n")
	sb.WriteString("- ' OR '1'='1 (basic injection)\n")
	sb.WriteString("- ' OR 1=1-- (comment-based)\n")
	sb.WriteString("- '; CREATE TABLE test_xyz789 AS SELECT 1; DROP TABLE test_xyz789; -- (destructive)\n")
	sb.WriteString("- ' UNION SELECT * FROM users-- (union-based)\n\n")

	sb.WriteString("### Content/Body Parameters\n")
	sb.WriteString("Test with:\n")
	sb.WriteString("- <script>alert('XSS')</script> (XSS)\n")
	sb.WriteString("- <img src=x onerror=alert(1)> (XSS variant)\n")
	sb.WriteString("- javascript:alert(1) (protocol handler)\n")
	sb.WriteString("- $(whoami) (command injection)\n")
	sb.WriteString("- {{7*7}} (template injection)\n\n")

	sb.WriteString("### File/Path Parameters\n")
	sb.WriteString("Test with:\n")
	sb.WriteString("- ../../../etc/passwd (directory traversal)\n")
	sb.WriteString("- ..\\..\\..\\windows\\system32\\config\\sam (Windows)\n")
	sb.WriteString("- /etc/passwd (absolute path)\n")
	sb.WriteString("- file:///etc/passwd (file protocol)\n\n")

	sb.WriteString("**For attack scenarios that should be blocked:**\n")
	sb.WriteString("```yaml\n")
	sb.WriteString("expected_output:\n")
	sb.WriteString("  error_present: true  # Attack should be blocked\n")
	sb.WriteString("  error_code_one_of: [400, 403, 404, -32602]\n")
	sb.WriteString("  error_response_must_not_match_regex:\n")
	sb.WriteString("    - \"Bearer [a-zA-Z0-9_-]{20,}\"  # Ensure error doesn't leak tokens\n")
	sb.WriteString("    - \"/home/[a-zA-Z0-9_-]+\"  # Ensure error doesn't leak internal paths\n")
	sb.WriteString("    - \"root:.*:0:0:\"  # Ensure error doesn't leak file contents\n")
	sb.WriteString("```\n\n")
	sb.WriteString("**IMPORTANT REGEX REQUIREMENTS:**\n")
	sb.WriteString("- All values in `error_response_must_not_match_regex` MUST be valid regex patterns\n")
	sb.WriteString("- If a specific string is used in the attack (e.g., \"/etc/passwd\"), the error message may naturally include this string - this is expected behavior, not information leakage. DO NOT use a regex pattern to match the attack payload itself in error messages.\n")
	sb.WriteString("**IMPORTANT:** Attack scenarios (credential exfiltration, SSRF, code injection, etc.) should use `error_present: true` because a secure system should block these attempts.\n\n")

	sb.WriteString("## Variable Substitution\n\n")
	sb.WriteString("Use ${VARIABLE_NAME} when tests need real/valid values. Declare in prerequisites:\n\n")
	sb.WriteString("```yaml\n")
	sb.WriteString("prerequisites:\n")
	sb.WriteString("  - description: \"Obtain from [tool_name] or user configuration\"\n")
	sb.WriteString("    variable: \"VALID_ID\"\n")
	sb.WriteString("```\n\n")

	sb.WriteString("# Tools to Analyze\n\n")

	// Add each tool with its schema
	sb.WriteString(fmt.Sprintf("## Tool name: %s\n\n", tool.Name))
	desc := tool.Description
	if len(desc) > 1000 {
		desc = desc[:1000]
	}
	sb.WriteString(fmt.Sprintf("**Description:** %s\n\n", desc))

	// Format and include schema
	if tool.InputSchema != nil {
		schemaBytes, _ := json.Marshal(tool.InputSchema)
		var schema map[string]interface{}
		if err := json.Unmarshal(schemaBytes, &schema); err == nil {
			schemaJSON, _ := json.MarshalIndent(schema, "", "  ")
			sb.WriteString("**Input Schema:**\n```json\n")
			sb.WriteString(string(schemaJSON))
			sb.WriteString("\n```\n\n")
		}
	}

	sb.WriteString("\n# Instructions\n\n")
	sb.WriteString("1. **Analyze each tool** for applicable vulnerabilities\n")
	sb.WriteString("2. **Select top 3-4 most critical** security tests\n")
	sb.WriteString("3. **Create 2-3 test cases** per test covering different attack vectors\n")
	sb.WriteString("5. **Use realistic attack payloads** appropriate for each parameter type\n")
	sb.WriteString("6. **Include information disclosure checks** in at least one test\n")

	sb.WriteString("# Output Requirements\n\n")
	sb.WriteString("- Generate ONLY valid YAML, no explanations or markdown\n")
	sb.WriteString("- Use the exact structure shown above\n")
	sb.WriteString("- **MANDATORY: Every test case expected_output MUST include 'success' and 'error_present' fields**\n")
	sb.WriteString("- Include specific attack payloads appropriate for each tool\n")
	sb.WriteString("- Specify precise expected outputs (error messages, regex patterns)\n")
	sb.WriteString("- Focus on realistic, high-impact vulnerabilities\n")
	sb.WriteString("- Each test must have a clear purpose explaining the security risk\n\n")

	sb.WriteString("BEGIN YAML OUTPUT:\n")

	return sb.String()
}

// mergeYAMLResponses merges multiple YAML test plan responses by extracting tests from each
// and combining them into a single YAML document with one metadata header.
func mergeYAMLResponses(responses []string, serverName string) (string, error) {
	if len(responses) == 0 {
		return "", fmt.Errorf("no responses to merge")
	}

	var allTests []Test

	// Extract tests from each response
	for i, response := range responses {
		yamlContent := strings.TrimSpace(response)
		if yamlContent == "" {
			fmt.Printf("Warning: No YAML found in response %d\n", i+1)
			continue
		}

		var testPlan TestPlan
		if err := yaml.Unmarshal([]byte(yamlContent), &testPlan); err != nil {
			return "", fmt.Errorf("failed to parse YAML in response %d: %w", i+1, err)
		}

		// Collect all tests (ignore metadata)
		allTests = append(allTests, testPlan.Tests...)
	}

	// Create merged plan with single metadata header
	mergedPlan := TestPlan{
		Tests: allTests,
	}
	mergedPlan.Metadata.Version = "1.0"
	mergedPlan.Metadata.Target = serverName
	mergedPlan.Metadata.Focus = "Critical security vulnerabilities"

	mergedYAML, err := yaml.Marshal(&mergedPlan)
	if err != nil {
		return "", fmt.Errorf("failed to marshal merged YAML: %w", err)
	}

	return string(mergedYAML), nil
}
