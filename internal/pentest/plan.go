package pentest

import (
	"context"
	_ "embed"
	"encoding/json"
	"fmt"
	"strings"

	"mcpxray/internal/llm"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"gopkg.in/yaml.v3"
)

//go:embed riskytoolsprompt.md
var riskyToolsPromptTemplate string

//go:embed generatepentestplan.md
var generatePentestPlanPromptTemplate string

// formatToolDescription truncates a tool description to 1000 characters if needed
func formatToolDescription(desc string) string {
	if len(desc) > 1000 {
		return desc[:1000]
	}
	return desc
}

// formatToolsList formats a list of tools into a markdown-formatted string
func formatToolsList(tools []mcp.Tool) string {
	var toolsList strings.Builder
	for i, tool := range tools {
		toolsList.WriteString(fmt.Sprintf("## Tool %d: %s\n\n", i+1, tool.Name))
		toolsList.WriteString(fmt.Sprintf("**Description:** %s\n\n", formatToolDescription(tool.Description)))
	}
	return toolsList.String()
}

func (t *PentestTool) GeneratePentestPlan(ctx context.Context, tools []mcp.Tool, mcpServerName string) (string, error) {
	riskyTools, err := t.IdentifyRiskyTools(ctx, tools)
	if err != nil {
		return "", err
	}

	// If no risky tools were identified, return an empty but valid YAML structure
	if len(riskyTools) == 0 {
		fmt.Printf("No risky tools identified for server %s, returning empty test plan\n", mcpServerName)
		emptyPlan := TestPlan{}
		emptyPlan.Metadata.Version = "1.0"
		emptyPlan.Metadata.Target = mcpServerName
		emptyPlan.Metadata.Focus = "Critical security vulnerabilities"
		emptyPlan.Tests = []Test{}

		emptyYAML, err := yaml.Marshal(&emptyPlan)
		if err != nil {
			return "", fmt.Errorf("failed to marshal empty YAML: %w", err)
		}
		return string(emptyYAML), nil
	}

	var responses []string
	for _, tool := range riskyTools {
		prompt := t.GenerateSecurityTestPrompt(tool, mcpServerName)
		fmt.Printf("Pentest plan prompt generated with length %v\n", len(prompt))
		response, err := t.llmClient.CallLLM(ctx, prompt, llm.OutputFormatYAML)
		if err != nil {
			return "", err
		}
		responses = append(responses, response)
	}

	mergedYAML, err := mergeYAMLResponses(responses, mcpServerName)
	if err != nil {
		return "", err
	}
	return mergedYAML, nil
}

func (t *PentestTool) IdentifyRiskyTools(ctx context.Context, tools []mcp.Tool) ([]mcp.Tool, error) {
	prompt := t.GenerateRiskyToolsPrompt(tools)
	fmt.Printf("Risky tools prompt generated with length %v\n", len(prompt))
	response, err := t.llmClient.CallLLM(ctx, prompt, llm.OutputFormatJSON)
	if err != nil {
		return nil, err
	}
	var riskyToolNames []string
	if err := json.Unmarshal([]byte(response), &riskyToolNames); err != nil {
		return nil, err
	}
	var riskyTools []mcp.Tool
	for _, toolName := range riskyToolNames {
		fmt.Printf("Adding risky tool: %s\n", toolName)
		for _, tool := range tools {
			if tool.Name == toolName {
				riskyTools = append(riskyTools, tool)
				break
			}
		}
	}
	return riskyTools, nil
}

func (t *PentestTool) GenerateRiskyToolsPrompt(tools []mcp.Tool) string {
	// Replace placeholder with actual tools list
	prompt := strings.ReplaceAll(riskyToolsPromptTemplate, "{{TOOLS_LIST}}", formatToolsList(tools))
	return prompt
}

// GenerateSecurityTestPrompt creates a general prompt for an LLM to generate security tests for any MCP
func (t *PentestTool) GenerateSecurityTestPrompt(tool mcp.Tool, serverName string) string {
	// Build the tool section
	var toolSection strings.Builder
	toolSection.WriteString(fmt.Sprintf("## Tool name: %s\n\n", tool.Name))
	toolSection.WriteString(fmt.Sprintf("**Description:** %s\n\n", formatToolDescription(tool.Description)))

	// Format and include schema
	if tool.InputSchema != nil {
		schemaBytes, _ := json.Marshal(tool.InputSchema)
		var schema map[string]interface{}
		if err := json.Unmarshal(schemaBytes, &schema); err == nil {
			schemaJSON, _ := json.MarshalIndent(schema, "", "  ")
			toolSection.WriteString("**Input Schema:**\n```json\n")
			toolSection.WriteString(string(schemaJSON))
			toolSection.WriteString("\n```\n\n")
		}
	}

	// Replace placeholders with actual values
	prompt := strings.ReplaceAll(generatePentestPlanPromptTemplate, "{{SERVER_NAME}}", serverName)
	prompt = strings.ReplaceAll(prompt, "{{TOOL_SECTION}}", toolSection.String())
	return prompt
}

// mergeYAMLResponses merges multiple YAML test plan responses by extracting tests from each
// and combining them into a single YAML document with one metadata header.
func mergeYAMLResponses(responses []string, serverName string) (string, error) {
	if len(responses) == 0 {
		return "", fmt.Errorf("no responses to merge")
	}

	var allTests []Test

	// Extract tests from each response
	for i, response := range responses {
		yamlContent := strings.TrimSpace(response)
		if yamlContent == "" {
			fmt.Printf("Warning: No YAML found in response %d\n", i+1)
			continue
		}

		var testPlan TestPlan
		if err := yaml.Unmarshal([]byte(yamlContent), &testPlan); err != nil {
			return "", fmt.Errorf("failed to parse YAML in response %d: %w", i+1, err)
		}

		// Collect all tests (ignore metadata)
		allTests = append(allTests, testPlan.Tests...)
	}

	// Create merged plan with single metadata header
	mergedPlan := TestPlan{
		Tests: allTests,
	}
	mergedPlan.Metadata.Version = "1.0"
	mergedPlan.Metadata.Target = serverName
	mergedPlan.Metadata.Focus = "Critical security vulnerabilities"

	mergedYAML, err := yaml.Marshal(&mergedPlan)
	if err != nil {
		return "", fmt.Errorf("failed to marshal merged YAML: %w", err)
	}

	return string(mergedYAML), nil
}
