package pentest

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
	"time"

	"mcpxray/internal/llm"
	"mcpxray/proto"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	"gopkg.in/yaml.v3"
)

// TestPlan represents the structure of a pentest YAML file
type TestPlan struct {
	Metadata struct {
		Version string `yaml:"version"`
		Target  string `yaml:"target"`
		Focus   string `yaml:"focus"`
	} `yaml:"metadata"`
	Tests []Test `yaml:"tests"`
}

// Test represents a single security test
type Test struct {
	TestID        string         `yaml:"test_id"`
	McpServerName string         `yaml:"mcp_server_name,omitempty"`
	Name          string         `yaml:"name"`
	Purpose       string         `yaml:"purpose"`
	Prerequisites []Prerequisite `yaml:"prerequisites,omitempty"`
	TestCases     []TestCase     `yaml:"test_cases"`
}

// Prerequisite represents a prerequisite that needs to be fulfilled
type Prerequisite struct {
	Description string `yaml:"description"`
	Variable    string `yaml:"variable"`
}

// TestCase represents a single test case
type TestCase struct {
	CaseID         string         `yaml:"case_id"`
	Description    string         `yaml:"description"`
	Input          TestInput      `yaml:"input"`
	ExpectedOutput ExpectedOutput `yaml:"expected_output"`
}

// TestInput represents the input for a test case
type TestInput struct {
	Tool      string                 `yaml:"tool"`
	Arguments map[string]interface{} `yaml:"arguments"`
}

// ExpectedOutput represents the expected output for a test case
type ExpectedOutput struct {
	ErrorPresent                   bool        `yaml:"error_present"`
	ErrorCodeOneOf                 []int       `yaml:"error_code_one_of,omitempty"`
	ErrorResponseMustNotMatchRegex []string    `yaml:"error_response_must_not_match_regex,omitempty"`
	Result                         interface{} `yaml:"result"`
}

// TestResult represents the result of executing a test case
type TestResult struct {
	CaseID      string
	Description string
	Passed      bool
	Error       string
	Details     string
	Severity    proto.RiskSeverity
}

// ExecuteTestPlan executes a test plan from a YAML file
func (t *PentestTool) ExecuteTestPlan(ctx context.Context, yamlPath string, serverName string) ([]*proto.Finding, error) {
	// Read and parse YAML file
	data, err := os.ReadFile(yamlPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read YAML file: %w", err)
	}

	var plan TestPlan
	if err := yaml.Unmarshal(data, &plan); err != nil {
		return nil, fmt.Errorf("failed to parse YAML: %w", err)
	}

	// Get session (cached)
	session, err := t.getSession(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get session: %w", err)
	}

	// Get available tools from the MCP server
	toolsList, err := session.ListTools(ctx, &mcp.ListToolsParams{})
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}
	tools := toolsList.Tools

	var findings []*proto.Finding
	variables := make(map[string]string)

	// Process each test
	for idx, test := range plan.Tests {
		fmt.Printf("Processing test %d: %s - %s\n", idx+1, test.TestID, test.Name)

		// Check if mcp_server_name matches the serverName parameter
		if test.McpServerName != "" && test.McpServerName != serverName {
			fmt.Printf("Skipping test %s: mcp_server_name '%s' does not match serverName '%s'\n", test.TestID, test.McpServerName, serverName)
			continue
		}

		// Handle prerequisites for this test
		if len(test.Prerequisites) > 0 {
			// Convert []*mcp.Tool to []mcp.Tool
			toolsSlice := make([]mcp.Tool, len(tools))
			for i, tool := range tools {
				toolsSlice[i] = *tool
			}
			prereqsFulfilled := true
			for _, prereq := range test.Prerequisites {
				if _, exists := variables[prereq.Variable]; !exists {
					fmt.Printf("Fulfilling prerequisite: %s (variable: %s)\n", prereq.Description, prereq.Variable)
					value, err := t.fulfillPrerequisite(ctx, prereq, toolsSlice)
					if err != nil {
						fmt.Printf("Failed to fulfill prerequisite %s: %v\n", prereq.Variable, err)
						prereqsFulfilled = false
						break
					}
					variables[prereq.Variable] = value
					fmt.Printf("Prerequisite fulfilled: %s = %s\n", prereq.Variable, value)
				}
			}

			if !prereqsFulfilled {
				fmt.Printf("Skipping test case %s due to unmet prerequisites.\n", test.TestID)
				continue
			}
		}

		// Process each test case
		for _, testCase := range test.TestCases {
			fmt.Printf("Executing test case: %s - %s\n", testCase.CaseID, testCase.Description)

			// Substitute variables in arguments
			args := substituteVariables(testCase.Input.Arguments, variables)

			// Execute the test case
			result := t.executeTestCase(ctx, testCase, testCase.Input.Tool, args)

			if result.Error != "" && strings.Contains(result.Error, "context deadline exceeded") {
				result.Passed = false
				result.Details = "Unable to complete the test case due to timeout"
				result.Severity = proto.RiskSeverity_RISK_SEVERITY_HIGH
			}

			if result.Passed {
				fmt.Printf("  ✓ Test case %s passed\n", testCase.CaseID)
			} else {
				fmt.Printf("  ✗ Test case %s failed: %s\n", testCase.CaseID, result.Error)
				details := result.Details
				if len(details) > 1000 {
					details = details[:1000] + "..."
				}
				// Convert failed test case to a finding
				findings = append(findings, &proto.Finding{
					Tool:          "pentest",
					Type:          proto.FindingType_FINDING_TYPE_PENTEST,
					Severity:      result.Severity,
					RuleId:        testCase.CaseID,
					Title:         fmt.Sprintf("%s: %s", test.TestID, testCase.Description),
					McpServerName: serverName,
					McpToolName:   testCase.Input.Tool,
					File:          yamlPath,
					Message:       fmt.Sprintf("%s. %s. Details: %s", testCase.Description, result.Error, details),
				})
			}
		}
	}

	return findings, nil
}

// fulfillPrerequisite uses an LLM to find the right tool to fulfill a prerequisite
func (t *PentestTool) fulfillPrerequisite(ctx context.Context, prereq Prerequisite, tools []mcp.Tool) (string, error) {
	// Build a prompt for the LLM to find the right tool
	var sb strings.Builder
	sb.WriteString("You are helping to fulfill a prerequisite for a security test.\n\n")
	sb.WriteString(fmt.Sprintf("Prerequisite description: %s\n", prereq.Description))
	sb.WriteString(fmt.Sprintf("Variable name: %s\n\n", prereq.Variable))
	sb.WriteString("Available tools:\n")
	for i, tool := range tools {
		sb.WriteString(fmt.Sprintf("%d. %s: %s\n", i+1, tool.Name, tool.Description))
		if tool.InputSchema != nil {
			schemaBytes, _ := json.Marshal(tool.InputSchema)
			var schema map[string]interface{}
			if err := json.Unmarshal(schemaBytes, &schema); err == nil {
				schemaJSON, _ := json.MarshalIndent(schema, "", "  ")
				sb.WriteString(fmt.Sprintf("   Input schema: %s\n", string(schemaJSON)))
			}
		}
	}
	sb.WriteString("\n")
	sb.WriteString("Based on the prerequisite description, determine:\n")
	sb.WriteString("1. Which tool should be used to fulfill this prerequisite?\n")
	sb.WriteString("2. What arguments should be passed to that tool?\n")
	sb.WriteString("3. What value from the tool's response should be extracted for the variable?\n\n")
	sb.WriteString("IMPORTANT: You must respond with ONLY valid JSON. Do not include any text before or after the JSON.\n")
	sb.WriteString("If you need to provide additional reasoning or explanations, include them in the \"info\" field.\n\n")
	sb.WriteString("Respond in JSON format:\n")
	sb.WriteString("{\n")
	sb.WriteString("  \"tool\": \"tool_name\",\n")
	sb.WriteString("  \"arguments\": {},\n")
	sb.WriteString("  \"extract_path\": \"path.to.value.in.response\",\n")
	sb.WriteString("  \"info\": \"optional explanation or reasoning\"\n")
	sb.WriteString("}\n")

	response, err := t.llmClient.CallLLM(ctx, sb.String(), llm.OutputFormatJSON)
	if err != nil {
		return "", fmt.Errorf("failed to call LLM: %w", err)
	}

	// Parse LLM response
	var llmResponse struct {
		Tool        string                 `json:"tool"`
		Arguments   map[string]interface{} `json:"arguments"`
		ExtractPath string                 `json:"extract_path"`
		Info        string                 `json:"info,omitempty"`
	}

	// Try to extract JSON from the response (might be wrapped in markdown)
	response = extractJSON(response)
	if err := json.Unmarshal([]byte(response), &llmResponse); err != nil {
		return "", fmt.Errorf("failed to parse LLM response: %w", err)
	}

	// Find the tool
	var selectedTool *mcp.Tool
	for i := range tools {
		if tools[i].Name == llmResponse.Tool {
			selectedTool = &tools[i]
			break
		}
	}
	if selectedTool == nil {
		return "", fmt.Errorf("tool %s not found", llmResponse.Tool)
	}

	// Get the latest session
	session, err := t.getSession(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to get session: %w", err)
	}

	// Call the tool using SDK
	callParams := &mcp.CallToolParams{
		Name:      llmResponse.Tool,
		Arguments: llmResponse.Arguments,
	}

	result, err := session.CallTool(ctx, callParams)
	if err != nil {
		return "", fmt.Errorf("failed to call tool %s: %w", llmResponse.Tool, err)
	}

	// Convert SDK result to JSON for extraction
	var resultJSON json.RawMessage
	if result.IsError {
		// MCP-style error in result
		errorContent := map[string]interface{}{
			"isError": true,
			"content": result.Content,
		}
		resultJSON, _ = json.Marshal(errorContent)
		return "", fmt.Errorf("tool %s returned error: %v", llmResponse.Tool, result.Content)
	} else {
		// Unwrap MCP response structure to get the actual data
		resultJSON = unwrapMCPResponse(result.Content)
	}

	fmt.Printf("Prerequisite tool call response:\n%s\n", string(resultJSON))

	// Extract the value from the response
	value, err := extractValueFromResponse(resultJSON, llmResponse.ExtractPath)
	if err != nil {
		return "", fmt.Errorf("failed to extract value from response: %w", err)
	}

	return fmt.Sprintf("%v", value), nil
}

// executeTestCase executes a single test case
func (t *PentestTool) executeTestCase(ctx context.Context, testCase TestCase, toolName string, args map[string]interface{}) TestResult {
	result := TestResult{
		CaseID:      testCase.CaseID,
		Description: testCase.Description,
		Passed:      false,
	}

	// Call the tool using SDK
	callParams := &mcp.CallToolParams{
		Name:      toolName,
		Arguments: args,
	}

	fmt.Printf("Tool request: name=%s, args=%+v\n", toolName, args)

	// Get session (cached)
	session, err := t.getSession(ctx)
	if err != nil {
		result.Error = fmt.Sprintf("Failed to get session: %v", err)
		return result
	}

	// Create a timeout context and wrap the call in a goroutine to ensure timeout works
	timeoutCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	// Use a channel to receive the result from the goroutine
	type callResult struct {
		result *mcp.CallToolResult
		err    error
	}
	resultChan := make(chan callResult, 1)

	// Call the tool in a goroutine
	go func() {
		toolResult, err := session.CallTool(timeoutCtx, callParams)
		// Use select to prevent blocking if timeout already occurred
		select {
		case resultChan <- callResult{result: toolResult, err: err}:
		case <-timeoutCtx.Done():
			// Timeout already occurred, discard result to prevent goroutine leak
		}
	}()

	// Wait for either completion or timeout
	var toolResult *mcp.CallToolResult
	select {
	case res := <-resultChan:
		toolResult = res.result
		err = res.err
	case <-timeoutCtx.Done():
		// Context cancelled - create a toolResult with timeout error
		// The goroutine will discard its result, preventing leak
		timeoutErr := fmt.Errorf("context deadline exceeded: %w", timeoutCtx.Err())
		toolResult = &mcp.CallToolResult{
			IsError: true,
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: timeoutErr.Error(),
				},
			},
		}
		err = timeoutErr
	}

	if err != nil {
		result.Error = fmt.Sprintf("Failed to call tool: %v", err)
		return result
	}

	fmt.Printf("Tool response is error: %v\n", toolResult.IsError)
	if len(toolResult.Content) > 0 {
		content := fmt.Sprintf("%v", toolResult.Content[0])
		if len(content) > 1000 {
			content = content[:1000]
		}
		fmt.Printf("Content:\n%s\n", content)
	}

	// Convert SDK result to JSON for processing
	var respJSON json.RawMessage
	var respError *struct {
		Code    int
		Message string
	}

	if toolResult.IsError {
		// Tool returned an error
		errorContent := map[string]interface{}{
			"isError": true,
			"content": toolResult.Content,
		}
		respJSON, _ = json.Marshal(errorContent)
		// Extract error message from content
		errorMsg := "Tool returned an error"
		if len(toolResult.Content) > 0 {
			// Content is an array, try to extract text from first element
			// Marshal the content to extract text field
			if contentBytes, err := json.Marshal(toolResult.Content); err == nil {
				var contentArray []map[string]interface{}
				if json.Unmarshal(contentBytes, &contentArray) == nil && len(contentArray) > 0 {
					if text, ok := contentArray[0]["text"].(string); ok {
						errorMsg = text

						// Extract error code from text
						if code, found := extractErrorCode(text); found {
							respError = &struct {
								Code    int
								Message string
							}{
								Code:    code,
								Message: text,
							}
						}
					}
				}
			}
		}
		// Only set default error if no code was extracted from text
		if respError == nil {
			respError = &struct {
				Code    int
				Message string
			}{
				Code:    -32001, // Unknown error code
				Message: errorMsg,
			}
		}
	} else {
		contentMap := map[string]interface{}{
			"content": toolResult.Content,
		}
		respJSON, _ = json.Marshal(contentMap)
	}

	// Check if error is present as expected
	if respError != nil {
		if !testCase.ExpectedOutput.ErrorPresent {
			result.Error = fmt.Sprintf("Unexpected error: %s (code: %d)", respError.Message, respError.Code)
			result.Severity = proto.RiskSeverity_RISK_SEVERITY_HIGH
			return result
		}

		// Check error code
		if respError.Code != -32001 && len(testCase.ExpectedOutput.ErrorCodeOneOf) > 0 {
			found := false
			for _, code := range testCase.ExpectedOutput.ErrorCodeOneOf {
				if respError.Code == code {
					found = true
					break
				}
			}
			if !found {
				result.Error = fmt.Sprintf("Error code %d not in expected list: %v", respError.Code, testCase.ExpectedOutput.ErrorCodeOneOf)
				result.Severity = proto.RiskSeverity_RISK_SEVERITY_MEDIUM
				return result
			}
		}

		// Check error response must not contain
		responseStr := string(respJSON)
		// Check error response must not match regex
		if len(testCase.ExpectedOutput.ErrorResponseMustNotMatchRegex) > 0 {
			for _, pattern := range testCase.ExpectedOutput.ErrorResponseMustNotMatchRegex {
				matched, err := regexp.MatchString(pattern, responseStr)
				if err != nil {
					result.Error = fmt.Sprintf("Invalid regex pattern: %s", pattern)
					return result
				}
				if matched {
					result.Error = fmt.Sprintf("Response matches forbidden regex: %s", pattern)
					if len(responseStr) > 1000 {
						result.Details = responseStr[:1000] + "..."
					} else {
						result.Details = responseStr
					}
					result.Severity = proto.RiskSeverity_RISK_SEVERITY_HIGH
					return result
				}
			}
		}

		result.Passed = true
		result.Details = fmt.Sprintf("Error as expected: %s", respError.Message)
		return result
	}

	// No error, check if error was expected
	if testCase.ExpectedOutput.ErrorPresent {
		result.Error = "Expected error but got success"
		result.Details = string(respJSON)
		result.Severity = proto.RiskSeverity_RISK_SEVERITY_HIGH
		return result
	}

	result.Passed = true
	result.Details = "Test case passed"
	return result
}

// substituteVariables replaces ${VARIABLE_NAME} in arguments with actual values
func substituteVariables(args map[string]interface{}, variables map[string]string) map[string]interface{} {
	result := make(map[string]interface{})
	for k, v := range args {
		switch val := v.(type) {
		case string:
			// Replace ${VARIABLE_NAME} with actual value
			for varName, varValue := range variables {
				val = strings.ReplaceAll(val, fmt.Sprintf("${%s}", varName), varValue)
			}
			result[k] = val
		case []interface{}:
			// Recursively substitute in arrays
			newArray := make([]interface{}, len(val))
			for i, item := range val {
				if str, ok := item.(string); ok {
					for varName, varValue := range variables {
						str = strings.ReplaceAll(str, fmt.Sprintf("${%s}", varName), varValue)
					}
					newArray[i] = str
				} else {
					newArray[i] = item
				}
			}
			result[k] = newArray
		default:
			result[k] = v
		}
	}
	return result
}

// extractJSON extracts JSON from a string that might be wrapped in markdown code blocks
func extractJSON(text string) string {
	// Remove markdown code blocks
	text = strings.TrimSpace(text)
	if strings.HasPrefix(text, "```") {
		lines := strings.Split(text, "\n")
		if len(lines) > 1 {
			// Remove first line (```json or ```)
			lines = lines[1:]
			// Remove last line if it's ```
			if len(lines) > 0 && strings.TrimSpace(lines[len(lines)-1]) == "```" {
				lines = lines[:len(lines)-1]
			}
			text = strings.Join(lines, "\n")
		}
	}
	return strings.TrimSpace(text)
}

// extractErrorCode extracts an error code from text using regex matching.
// Matches patterns like "code xxx" or "code: xxx" (case-insensitive).
// Returns the extracted code and true if found, otherwise returns 0 and false.
func extractErrorCode(text string) (int, bool) {
	// Matches patterns like "code xxx" or "code: xxx"
	codePattern := regexp.MustCompile(`(?i)code\s*:?\s*(-?\d+)`)
	matches := codePattern.FindStringSubmatch(text)
	if len(matches) > 1 {
		var code int
		if _, err := fmt.Sscanf(matches[1], "%d", &code); err == nil {
			return code, true
		}
	}
	return 0, false
}

// unwrapMCPResponse extracts the actual data from an MCP tool response structure.
// MCP tools return data in content[0].text as a JSON string. This function unwraps
// that structure and returns the parsed JSON, or the original structure if unwrapping fails.
func unwrapMCPResponse(content []mcp.Content) json.RawMessage {
	if len(content) == 0 {
		contentMap := map[string]interface{}{
			"content": content,
		}
		result, _ := json.Marshal(contentMap)
		return result
	}

	contentBytes, err := json.Marshal(content)
	if err != nil {
		contentMap := map[string]interface{}{
			"content": content,
		}
		result, _ := json.Marshal(contentMap)
		return result
	}

	var contentArray []map[string]interface{}
	if err := json.Unmarshal(contentBytes, &contentArray); err != nil || len(contentArray) == 0 {
		contentMap := map[string]interface{}{
			"content": content,
		}
		result, _ := json.Marshal(contentMap)
		return result
	}

	text, ok := contentArray[0]["text"].(string)
	if !ok || text == "" {
		contentMap := map[string]interface{}{
			"content": content,
		}
		result, _ := json.Marshal(contentMap)
		return result
	}

	// Try to parse the JSON string from text field
	var parsedData interface{}
	if err := json.Unmarshal([]byte(text), &parsedData); err == nil {
		// Successfully parsed - return the parsed JSON
		result, _ := json.Marshal(parsedData)
		return result
	}

	// If parsing fails, return the text as-is
	return []byte(text)
}

// extractValueFromResponse extracts a value from a JSON response using a dot-notation path
// Supports paths like "field.subfield", "[0].id", "resources[0].id", etc.
func extractValueFromResponse(response json.RawMessage, path string) (interface{}, error) {
	var data interface{}
	if err := json.Unmarshal(response, &data); err != nil {
		return nil, err
	}

	// If the response is a scalar (string/number/bool/null), return it directly even
	// if a path was provided. Some tools legitimately return a bare value, and paths
	// like "id" would otherwise fail on non-map types.
	switch data.(type) {
	case string, float64, bool, nil:
		return data, nil
	}

	if path == "" {
		return data, nil
	}

	current := data

	// Parse the path to handle bracket notation like [0].id or field[0].subfield
	// We'll split by '.' but also handle [index] notation
	i := 0
	for i < len(path) {
		// Skip leading dots
		if path[i] == '.' {
			i++
			continue
		}

		// Check if we have bracket notation [index]
		if path[i] == '[' {
			// Find the closing bracket
			closeIdx := strings.IndexByte(path[i:], ']')
			if closeIdx == -1 {
				return nil, fmt.Errorf("unclosed bracket in path: %s", path)
			}
			closeIdx += i

			// Extract the index
			indexStr := path[i+1 : closeIdx]
			var idx int
			if _, err := fmt.Sscanf(indexStr, "%d", &idx); err != nil {
				return nil, fmt.Errorf("invalid array index: %s", indexStr)
			}

			// Access the array
			arr, ok := current.([]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot index into non-array at position %d in path %s", i, path)
			}
			if idx < 0 || idx >= len(arr) {
				return nil, fmt.Errorf("array index %d out of bounds (length: %d) in path %s", idx, len(arr), path)
			}
			current = arr[idx]

			// Move past the bracket notation
			i = closeIdx + 1
		} else {
			// Extract field name (until next '.' or '[')
			fieldEnd := i
			for fieldEnd < len(path) && path[fieldEnd] != '.' && path[fieldEnd] != '[' {
				fieldEnd++
			}
			fieldName := path[i:fieldEnd]

			// Access the map field
			m, ok := current.(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot access field %s on non-map at position %d in path %s", fieldName, i, path)
			}
			var exists bool
			current, exists = m[fieldName]
			if !exists {
				return nil, fmt.Errorf("path %s not found in response (field %s missing)", path, fieldName)
			}

			i = fieldEnd
		}
	}

	return current, nil
}
