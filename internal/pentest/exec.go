package pentest

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
	"sync/atomic"

	"mcpxray/internal/libmcp"
	"mcpxray/proto"

	"gopkg.in/yaml.v3"
)

var requestIDCounter int64

// TestPlan represents the structure of a pentest YAML file
type TestPlan struct {
	Metadata struct {
		Version string `yaml:"version"`
		Target  string `yaml:"target"`
		Focus   string `yaml:"focus"`
	} `yaml:"metadata"`
	Tests []Test `yaml:"tests"`
}

// Test represents a single security test
type Test struct {
	TestID        string         `yaml:"test_id"`
	Name          string         `yaml:"name"`
	Purpose       string         `yaml:"purpose"`
	Severity      string         `yaml:"severity"`
	Prerequisites []Prerequisite `yaml:"prerequisites,omitempty"`
	TestCases     []TestCase     `yaml:"test_cases"`
}

// Prerequisite represents a prerequisite that needs to be fulfilled
type Prerequisite struct {
	Description string `yaml:"description"`
	Variable    string `yaml:"variable"`
}

// TestCase represents a single test case
type TestCase struct {
	CaseID         string         `yaml:"case_id"`
	Description    string         `yaml:"description"`
	Input          TestInput      `yaml:"input"`
	ExpectedOutput ExpectedOutput `yaml:"expected_output"`
}

// TestInput represents the input for a test case
type TestInput struct {
	Tool      string                 `yaml:"tool"`
	Arguments map[string]interface{} `yaml:"arguments"`
}

// ExpectedOutput represents the expected output for a test case
type ExpectedOutput struct {
	Success                        bool        `yaml:"success"`
	ErrorPresent                   bool        `yaml:"error_present"`
	ErrorCodeOneOf                 []int       `yaml:"error_code_one_of,omitempty"`
	ErrorMessageContainsOneOf      []string    `yaml:"error_message_contains_one_of,omitempty"`
	ErrorResponseMustNotMatchRegex []string    `yaml:"error_response_must_not_match_regex,omitempty"`
	ErrorResponseMustNotContain    []string    `yaml:"error_response_must_not_contain,omitempty"`
	Result                         interface{} `yaml:"result"`
}

// TestResult represents the result of executing a test case
type TestResult struct {
	CaseID      string
	Description string
	Passed      bool
	Error       string
	Details     string
}

// ExecuteTestPlan executes a test plan from a YAML file
func (t *PentestTool) ExecuteTestPlan(ctx context.Context, yamlPath string, session libmcp.MCPSession, serverName string) ([]proto.Finding, error) {
	// Read and parse YAML file
	data, err := os.ReadFile(yamlPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read YAML file: %w", err)
	}

	var plan TestPlan
	if err := yaml.Unmarshal(data, &plan); err != nil {
		return nil, fmt.Errorf("failed to parse YAML: %w", err)
	}

	// Get available tools from the MCP server
	tools, err := libmcp.GetTools(ctx, session)
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}

	var findings []proto.Finding
	variables := make(map[string]string)

	// Process each test
	for _, test := range plan.Tests {
		fmt.Printf("Processing test: %s - %s\n", test.TestID, test.Name)

		// Handle prerequisites for this test
		if len(test.Prerequisites) > 0 {
			for _, prereq := range test.Prerequisites {
				if _, exists := variables[prereq.Variable]; !exists {
					fmt.Printf("Fulfilling prerequisite: %s (variable: %s)\n", prereq.Description, prereq.Variable)
					value, err := t.fulfillPrerequisite(ctx, prereq, tools, session)
					if err != nil {
						return nil, fmt.Errorf("failed to fulfill prerequisite %s: %w", prereq.Variable, err)
					}
					variables[prereq.Variable] = value
					fmt.Printf("Prerequisite fulfilled: %s = %s\n", prereq.Variable, value)
				}
			}
		}

		// Process each test case
		for _, testCase := range test.TestCases {
			fmt.Printf("  Executing test case: %s - %s\n", testCase.CaseID, testCase.Description)

			// Substitute variables in arguments
			args := substituteVariables(testCase.Input.Arguments, variables)

			// Execute the test case
			result := t.executeTestCase(ctx, testCase, testCase.Input.Tool, args, session)

			if result.Passed {
				fmt.Printf("  ✓ Test case %s passed\n", testCase.CaseID)
			} else {
				fmt.Printf("  ✗ Test case %s failed: %s\n", testCase.CaseID, result.Error)
				// Convert failed test case to a finding
				finding := proto.Finding{
					Tool:          "pentest",
					Type:          proto.FindingType_FINDING_TYPE_SAST,
					Severity:      mapSeverity(test.Severity),
					RuleId:        testCase.CaseID,
					Title:         fmt.Sprintf("%s: %s", test.TestID, testCase.Description),
					McpServerName: serverName,
					McpToolName:   testCase.Input.Tool,
					File:          yamlPath,
					Message:       fmt.Sprintf("Test case failed: %s. Details: %s", result.Error, result.Details),
				}
				findings = append(findings, finding)
			}
		}
	}

	return findings, nil
}

// fulfillPrerequisite uses an LLM to find the right tool to fulfill a prerequisite
func (t *PentestTool) fulfillPrerequisite(ctx context.Context, prereq Prerequisite, tools []libmcp.Tool, session libmcp.MCPSession) (string, error) {
	// Build a prompt for the LLM to find the right tool
	var sb strings.Builder
	sb.WriteString("You are helping to fulfill a prerequisite for a security test.\n\n")
	sb.WriteString(fmt.Sprintf("Prerequisite description: %s\n", prereq.Description))
	sb.WriteString(fmt.Sprintf("Variable name: %s\n\n", prereq.Variable))
	sb.WriteString("Available tools:\n")
	for i, tool := range tools {
		sb.WriteString(fmt.Sprintf("%d. %s: %s\n", i+1, tool.Name, tool.Description))
		if len(tool.InputSchema) > 0 {
			var schema map[string]interface{}
			if err := json.Unmarshal(tool.InputSchema, &schema); err == nil {
				schemaJSON, _ := json.MarshalIndent(schema, "", "  ")
				sb.WriteString(fmt.Sprintf("   Input schema: %s\n", string(schemaJSON)))
			}
		}
	}
	sb.WriteString("\n")
	sb.WriteString("Based on the prerequisite description, determine:\n")
	sb.WriteString("1. Which tool should be used to fulfill this prerequisite?\n")
	sb.WriteString("2. What arguments should be passed to that tool?\n")
	sb.WriteString("3. What value from the tool's response should be extracted for the variable?\n\n")
	sb.WriteString("Respond in JSON format:\n")
	sb.WriteString("{\n")
	sb.WriteString("  \"tool\": \"tool_name\",\n")
	sb.WriteString("  \"arguments\": {},\n")
	sb.WriteString("  \"extract_path\": \"path.to.value.in.response\"\n")
	sb.WriteString("}\n")

	response, err := t.llmClient.CallLLM(ctx, sb.String())
	if err != nil {
		return "", fmt.Errorf("failed to call LLM: %w", err)
	}

	// Parse LLM response
	var llmResponse struct {
		Tool        string                 `json:"tool"`
		Arguments   map[string]interface{} `json:"arguments"`
		ExtractPath string                 `json:"extract_path"`
	}

	// Try to extract JSON from the response (might be wrapped in markdown)
	response = extractJSON(response)
	if err := json.Unmarshal([]byte(response), &llmResponse); err != nil {
		return "", fmt.Errorf("failed to parse LLM response: %w", err)
	}

	// Find the tool
	var selectedTool *libmcp.Tool
	for i := range tools {
		if tools[i].Name == llmResponse.Tool {
			selectedTool = &tools[i]
			break
		}
	}
	if selectedTool == nil {
		return "", fmt.Errorf("tool %s not found", llmResponse.Tool)
	}

	// Call the tool
	toolReq := libmcp.MCPRequest{
		JSONRPC: "2.0",
		Method:  "tools/call",
		Params: map[string]interface{}{
			"name":      llmResponse.Tool,
			"arguments": llmResponse.Arguments,
		},
		ID: int(atomic.AddInt64(&requestIDCounter, 1)),
	}

	resp, err := session.SendRequest(ctx, toolReq)
	if err != nil {
		return "", fmt.Errorf("failed to call tool %s: %w", llmResponse.Tool, err)
	}

	if resp.Error != nil {
		return "", fmt.Errorf("tool %s returned error: %s", llmResponse.Tool, resp.Error.Message)
	}

	// Extract the value from the response
	value, err := extractValueFromResponse(resp.Result, llmResponse.ExtractPath)
	if err != nil {
		return "", fmt.Errorf("failed to extract value from response: %w", err)
	}

	return fmt.Sprintf("%v", value), nil
}

// executeTestCase executes a single test case
func (t *PentestTool) executeTestCase(ctx context.Context, testCase TestCase, toolName string, args map[string]interface{}, session libmcp.MCPSession) TestResult {
	result := TestResult{
		CaseID:      testCase.CaseID,
		Description: testCase.Description,
		Passed:      false,
	}

	// Call the tool
	toolReq := libmcp.MCPRequest{
		JSONRPC: "2.0",
		Method:  "tools/call",
		Params: map[string]interface{}{
			"name":      toolName,
			"arguments": args,
		},
		ID: int(atomic.AddInt64(&requestIDCounter, 1)),
	}

	resp, err := session.SendRequest(ctx, toolReq)
	if err != nil {
		result.Error = fmt.Sprintf("Failed to call tool: %v", err)
		return result
	}

	// Check if error is present as expected
	if resp.Error != nil {
		if !testCase.ExpectedOutput.ErrorPresent {
			result.Error = fmt.Sprintf("Unexpected error: %s (code: %d)", resp.Error.Message, resp.Error.Code)
			return result
		}

		// Check error code
		if len(testCase.ExpectedOutput.ErrorCodeOneOf) > 0 {
			found := false
			for _, code := range testCase.ExpectedOutput.ErrorCodeOneOf {
				if resp.Error.Code == code {
					found = true
					break
				}
			}
			if !found {
				result.Error = fmt.Sprintf("Error code %d not in expected list: %v", resp.Error.Code, testCase.ExpectedOutput.ErrorCodeOneOf)
				return result
			}
		}

		// Check error message
		if len(testCase.ExpectedOutput.ErrorMessageContainsOneOf) > 0 {
			found := false
			errorMsg := strings.ToLower(resp.Error.Message)
			for _, expected := range testCase.ExpectedOutput.ErrorMessageContainsOneOf {
				if strings.Contains(errorMsg, strings.ToLower(expected)) {
					found = true
					break
				}
			}
			if !found {
				result.Error = fmt.Sprintf("Error message does not contain expected strings. Got: %s", resp.Error.Message)
				return result
			}
		}

		// Check error response must not contain
		responseStr := string(resp.Result)
		if len(testCase.ExpectedOutput.ErrorResponseMustNotContain) > 0 {
			for _, forbidden := range testCase.ExpectedOutput.ErrorResponseMustNotContain {
				if strings.Contains(responseStr, forbidden) {
					result.Error = fmt.Sprintf("Response contains forbidden string: %s", forbidden)
					return result
				}
			}
		}

		// Check error response must not match regex
		if len(testCase.ExpectedOutput.ErrorResponseMustNotMatchRegex) > 0 {
			for _, pattern := range testCase.ExpectedOutput.ErrorResponseMustNotMatchRegex {
				matched, err := regexp.MatchString(pattern, responseStr)
				if err != nil {
					result.Error = fmt.Sprintf("Invalid regex pattern: %s", pattern)
					return result
				}
				if matched {
					result.Error = fmt.Sprintf("Response matches forbidden regex: %s", pattern)
					return result
				}
			}
		}

		result.Passed = true
		result.Details = fmt.Sprintf("Error as expected: %s", resp.Error.Message)
		return result
	}

	// No error, check if error was expected
	if testCase.ExpectedOutput.ErrorPresent {
		result.Error = "Expected error but got success"
		return result
	}

	// Check success
	if !testCase.ExpectedOutput.Success {
		result.Error = "Expected failure but got success"
		return result
	}

	result.Passed = true
	result.Details = "Test case passed"
	return result
}

// substituteVariables replaces ${VARIABLE_NAME} in arguments with actual values
func substituteVariables(args map[string]interface{}, variables map[string]string) map[string]interface{} {
	result := make(map[string]interface{})
	for k, v := range args {
		switch val := v.(type) {
		case string:
			// Replace ${VARIABLE_NAME} with actual value
			for varName, varValue := range variables {
				val = strings.ReplaceAll(val, fmt.Sprintf("${%s}", varName), varValue)
			}
			result[k] = val
		case []interface{}:
			// Recursively substitute in arrays
			newArray := make([]interface{}, len(val))
			for i, item := range val {
				if str, ok := item.(string); ok {
					for varName, varValue := range variables {
						str = strings.ReplaceAll(str, fmt.Sprintf("${%s}", varName), varValue)
					}
					newArray[i] = str
				} else {
					newArray[i] = item
				}
			}
			result[k] = newArray
		default:
			result[k] = v
		}
	}
	return result
}

// extractJSON extracts JSON from a string that might be wrapped in markdown code blocks
func extractJSON(text string) string {
	// Remove markdown code blocks
	text = strings.TrimSpace(text)
	if strings.HasPrefix(text, "```") {
		lines := strings.Split(text, "\n")
		if len(lines) > 1 {
			// Remove first line (```json or ```)
			lines = lines[1:]
			// Remove last line if it's ```
			if len(lines) > 0 && strings.TrimSpace(lines[len(lines)-1]) == "```" {
				lines = lines[:len(lines)-1]
			}
			text = strings.Join(lines, "\n")
		}
	}
	return strings.TrimSpace(text)
}

// extractValueFromResponse extracts a value from a JSON response using a dot-notation path
// Supports paths like "field.subfield", "[0].id", "resources[0].id", etc.
func extractValueFromResponse(response json.RawMessage, path string) (interface{}, error) {
	var data interface{}
	if err := json.Unmarshal(response, &data); err != nil {
		return nil, err
	}

	if path == "" {
		return data, nil
	}

	current := data

	// Parse the path to handle bracket notation like [0].id or field[0].subfield
	// We'll split by '.' but also handle [index] notation
	i := 0
	for i < len(path) {
		// Skip leading dots
		if path[i] == '.' {
			i++
			continue
		}

		// Check if we have bracket notation [index]
		if path[i] == '[' {
			// Find the closing bracket
			closeIdx := strings.IndexByte(path[i:], ']')
			if closeIdx == -1 {
				return nil, fmt.Errorf("unclosed bracket in path: %s", path)
			}
			closeIdx += i

			// Extract the index
			indexStr := path[i+1 : closeIdx]
			var idx int
			if _, err := fmt.Sscanf(indexStr, "%d", &idx); err != nil {
				return nil, fmt.Errorf("invalid array index: %s", indexStr)
			}

			// Access the array
			arr, ok := current.([]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot index into non-array at position %d in path %s", i, path)
			}
			if idx < 0 || idx >= len(arr) {
				return nil, fmt.Errorf("array index %d out of bounds (length: %d) in path %s", idx, len(arr), path)
			}
			current = arr[idx]

			// Move past the bracket notation
			i = closeIdx + 1
		} else {
			// Extract field name (until next '.' or '[')
			fieldEnd := i
			for fieldEnd < len(path) && path[fieldEnd] != '.' && path[fieldEnd] != '[' {
				fieldEnd++
			}
			fieldName := path[i:fieldEnd]

			// Access the map field
			m, ok := current.(map[string]interface{})
			if !ok {
				return nil, fmt.Errorf("cannot access field %s on non-map at position %d in path %s", fieldName, i, path)
			}
			var exists bool
			current, exists = m[fieldName]
			if !exists {
				return nil, fmt.Errorf("path %s not found in response (field %s missing)", path, fieldName)
			}

			i = fieldEnd
		}
	}

	return current, nil
}

// mapSeverity maps string severity to proto.RiskSeverity
func mapSeverity(severity string) proto.RiskSeverity {
	severity = strings.ToLower(strings.TrimSpace(severity))
	switch severity {
	case "critical":
		return proto.RiskSeverity_RISK_SEVERITY_CRITICAL
	case "high":
		return proto.RiskSeverity_RISK_SEVERITY_HIGH
	case "medium":
		return proto.RiskSeverity_RISK_SEVERITY_MEDIUM
	case "low":
		return proto.RiskSeverity_RISK_SEVERITY_LOW
	default:
		return proto.RiskSeverity_RISK_SEVERITY_UNKNOWN
	}
}
