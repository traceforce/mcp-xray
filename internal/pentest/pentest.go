package pentest

import (
	"context"
	"fmt"
	"os"
	"time"

	"mcpxray/internal/libmcp"
	"mcpxray/internal/llm"
	"mcpxray/proto"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

type PentestTool struct {
	configPath   string
	llmClient    *llm.LLMClient
	session      *libmcp.SDKSession
	serverConfig *libmcp.MCPServerConfig
}

func NewPentestTool(configPath string, model string) (*PentestTool, error) {
	var llmClient *llm.LLMClient
	var err error
	if model != "" {
		llmClient, err = llm.NewLLMClientFromEnvWithModel(model, 30*time.Second)
		if err != nil {
			return nil, err
		}
	}
	return &PentestTool{
		configPath: configPath,
		llmClient:  llmClient,
	}, nil
}

func (t *PentestTool) Pentest(ctx context.Context, testPlanFile string) ([]proto.Finding, error) {
	// Parse configPath
	servers, err := libmcp.NewConfigParser(t.configPath).Parse()
	if err != nil {
		return nil, err
	}

	var allFindings []proto.Finding

	for _, server := range servers {
		// Cache server config and create initial session
		t.serverConfig = &server
		session, err := libmcp.NewSDKSession(ctx, server)
		if err != nil {
			fmt.Printf("Skipping server %s: Failed to create SDK session: %v\n", server.Name, err)
			continue
		}
		t.session = session
		defer func() {
			if t.session != nil {
				_ = t.session.Close()
			}
		}()

		// Get tools using SDK
		toolsList, err := t.session.Session.ListTools(ctx, &mcp.ListToolsParams{})
		if err != nil {
			return nil, err
		}
		tools := toolsList.Tools

		if len(tools) == 0 {
			continue
		}

		// Convert []*mcp.Tool to []mcp.Tool
		toolsSlice := make([]mcp.Tool, len(tools))
		for i, tool := range tools {
			toolsSlice[i] = *tool
		}

		if testPlanFile == "" {
			fileContent, err := t.GeneratePentestPlan(ctx, toolsSlice, server.Name)
			if err != nil {
				return nil, fmt.Errorf("failed to generate pentest plan: %w", err)
			}
			testPlanFile = fmt.Sprintf("pentest_plan_%s_%s.yaml", server.Name, time.Now().Format(time.RFC3339))
			err = os.WriteFile(testPlanFile, []byte(fileContent), 0644)
			if err != nil {
				return nil, fmt.Errorf("failed to write pentest plan to file: %w", err)
			}
		}

		findings, err := t.ExecuteTestPlan(ctx, testPlanFile, server.Name)
		if err != nil {
			return nil, fmt.Errorf("failed to execute pentest plan: %w", err)
		}
		allFindings = append(allFindings, findings...)

		// Clear session for next server
		if t.session != nil {
			_ = t.session.Close()
			t.session = nil
		}
		t.serverConfig = nil
	}

	return allFindings, nil
}

// getSession returns the cached session, creating it if necessary or recreating it if needed
func (t *PentestTool) getSession(ctx context.Context) (*mcp.ClientSession, error) {
	if t.session != nil {
		return t.session.Session, nil
	}
	if t.serverConfig == nil {
		return nil, fmt.Errorf("server config not set")
	}
	sdkSession, err := libmcp.NewSDKSession(ctx, *t.serverConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}
	t.session = sdkSession
	return t.session.Session, nil
}
