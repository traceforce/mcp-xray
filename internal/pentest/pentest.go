package pentest

import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"mcpxray/internal/libmcp"
	"mcpxray/internal/llm"
	"mcpxray/proto"
)

type PentestTool struct {
	configPath string
	llmClient  *llm.LLMClient
}

func NewPentestTool(configPath string, model string) (*PentestTool, error) {
	llmClient, err := llm.NewLLMClientFromEnvWithModel(model, 30*time.Second)
	if err != nil {
		return nil, err
	}
	return &PentestTool{
		configPath: configPath,
		llmClient:  llmClient,
	}, nil
}

func (t *PentestTool) Pentest(ctx context.Context) ([]proto.Finding, error) {
	// Parse configPath
	servers, err := libmcp.NewConfigParser(t.configPath).Parse()
	if err != nil {
		return nil, err
	}

	fmt.Printf("Tools scanner scanning %d MCP servers\n", len(servers))

	var allFindings []proto.Finding
	var serverToolsData []libmcp.ServerToolsData

	for _, server := range servers {
		session, err := libmcp.NewMCPSession(ctx, server)
		if err != nil {
			return nil, err
		}
		defer session.Close()

		tools, err := libmcp.GetTools(ctx, session)
		if err != nil {
			// If the error is a 401 Unauthorized error, report a medium severity finding
			// and suggest the user to check the OAuth scopes.
			if strings.Contains(err.Error(), "401") {
				allFindings = append(allFindings, proto.Finding{
					Tool:          "tools-scanner",
					Type:          proto.FindingType_FINDING_TYPE_CONNECTION,
					Severity:      proto.RiskSeverity_RISK_SEVERITY_MEDIUM,
					RuleId:        "401_unauthorized",
					Title:         "MCP server returned 401 Unauthorized error",
					McpServerName: server.Name,
					File:          t.configPath,
					Message:       fmt.Sprintf("Authorization issue: Failed to get tools from MCP server '%s' due to 401 Unauthorized error. This may indicate missing or invalid authentication credentials, or insufficient OAuth scopes. Error: %v", server.Name, err),
				})
				continue
			}
			return nil, err
		}

		// Collect tools data for JSON output (even if empty)
		serverToolsData = append(serverToolsData, libmcp.ServerToolsData{
			Server: server.Name,
			Tools:  tools,
		})

		if len(tools) == 0 {
			continue
		}

		// TODO: FIXME, do not restrict the number of tools to 3
		plan, err := t.GeneratePentestPlan(ctx, tools[3:4])
		if err != nil {
			return nil, fmt.Errorf("failed to generate pentest plan: %w", err)
		}
		planFilename := fmt.Sprintf("pentest_plan_%s_%v.yaml", server.Name, time.Now().Format(time.RFC3339))
		if err := os.WriteFile(planFilename, []byte(plan), 0644); err != nil {
			return nil, fmt.Errorf("failed to write pentest plan to file: %w", err)
		}
		fmt.Printf("Pentest plan written to %s\n", planFilename)

		findings, err := t.ExecuteTestPlan(ctx, planFilename, session, server.Name)
		if err != nil {
			return nil, fmt.Errorf("failed to execute pentest plan: %w", err)
		}
		allFindings = append(allFindings, findings...)
	}

	return allFindings, nil
}

// type PentestTool struct {
// }

// func NewPentestTool() *PentestTool {
// 	return &PentestTool{}
// }

// func (t *PentestTool) PentestTools(ctx context.Context, tools []Tool, mcpServerName string,
// 	configPath string, session MCPSession) ([]proto.Finding, error) {
// 	var allFindings []proto.Finding
// 	for _, tool := range tools {
// 		findings, err := t.CallTool(ctx, tool, mcpServerName, configPath, session)
// 		if err != nil {
// 			return nil, err
// 		}
// 		allFindings = append(allFindings, findings...)
// 	}
// 	return allFindings, nil
// }

// // ToolCallResult represents the result of a tool/call response
// type ToolCallResult struct {
// 	Content []interface{} `json:"content,omitempty"`
// 	IsError bool          `json:"isError,omitempty"`
// }

// func (t *PentestTool) CallTool(ctx context.Context, tool Tool, mcpServerName string,
// 	configPath string, session MCPSession) ([]proto.Finding, error) {
// 	var findings []proto.Finding

// 	// Build minimal/safe arguments for the tool call
// 	// For pentesting, we try to call with minimal arguments to see what happens
// 	arguments := make(map[string]interface{})

// 	// If the tool has an input schema, try to extract required fields and provide minimal values
// 	if len(tool.InputSchema) > 0 {
// 		var schema map[string]interface{}
// 		if err := json.Unmarshal(tool.InputSchema, &schema); err == nil {
// 			// Extract properties and required fields from JSON schema
// 			properties, propertiesOk := schema["properties"].(map[string]interface{})
// 			required, requiredOk := schema["required"].([]interface{})

// 			if propertiesOk && requiredOk {
// 				// For required fields, provide minimal safe values
// 				for _, reqField := range required {
// 					fieldName, fieldNameOk := reqField.(string)
// 					if !fieldNameOk {
// 						continue
// 					}

// 					propRaw, propExists := properties[fieldName]
// 					if !propExists {
// 						continue
// 					}

// 					prop, propOk := propRaw.(map[string]interface{})
// 					if !propOk {
// 						continue
// 					}

// 					// Provide default value based on type
// 					propType, propTypeOk := prop["type"].(string)
// 					if !propTypeOk {
// 						continue
// 					}

// 					switch propType {
// 					case "string":
// 						arguments[fieldName] = "test"
// 					case "number", "integer":
// 						arguments[fieldName] = 1
// 					case "boolean":
// 						arguments[fieldName] = false
// 					case "array":
// 						arguments[fieldName] = []interface{}{}
// 					case "object":
// 						arguments[fieldName] = map[string]interface{}{}
// 					}
// 				}
// 			}
// 		}
// 	}

// 	// Build the tool/call request
// 	toolReq := MCPRequest{
// 		JSONRPC: MCPJSONRPCVersion,
// 		Method:  "tools/call",
// 		Params: map[string]interface{}{
// 			"name":      tool.Name,
// 			"arguments": arguments,
// 		},
// 		ID: int(atomic.AddInt64(&requestIDCounter, 1)),
// 	}

// 	// Send the request
// 	_, err := session.SendRequest(ctx, toolReq)
// 	if err != nil {
// 		// If sending the request fails, create a finding about the failure
// 		findings = append(findings, proto.Finding{
// 			Tool:          "pentest_tool",
// 			Type:          proto.FindingType_FINDING_TYPE_CONNECTION,
// 			Severity:      proto.RiskSeverity_RISK_SEVERITY_MEDIUM,
// 			RuleId:        "tool_call_request_failed",
// 			Title:         fmt.Sprintf("Failed to send tool call request for tool '%s'", tool.Name),
// 			McpServerName: mcpServerName,
// 			McpToolName:   tool.Name,
// 			File:          configPath,
// 			Message:       fmt.Sprintf("Error sending tool/call request: %v", err),
// 		})
// 		return findings, nil
// 	}

// 	return findings, nil
// }
